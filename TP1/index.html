<!doctype html>
<head>
    <script src="js/otros/jquery.js"></script>
    <script src="js/otros/gl-matrix-3.3.0.js"></script>
    <script src="js/otros/webgl-utils.js"></script>
    <script src="js/otros/dat.gui.js"></script>
    <script src="js/otros/jquery.mousewheel.min.js"></script>

    <script src="js/camaras/droneCamera.js"></script>
    <script src="js/camaras/orbitalCamera.js"></script>

    <script src="js/estructuras/modulo-geometria.js"></script>
    <script src="js/estructuras/modulo-curvas.js"></script>
    <script src="js/estructuras/modulo-estructura.js"></script>
    <script src="js/estructuras/perlin-noise.js"></script>
    <script src="js/estructuras/Objeto3D.js"></script>

<style>
        html{
            height: 100%;
        }
        body{
            padding: 0;
            margin: 0;
            height: 100%;;
        }

        #myCanvas{
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>

</head>

<body>

    <canvas id="myCanvas" >
        Your browser does not support the HTML5 canvas element.
    </canvas>


    <script>

        var modo="edges"; // wireframe, smooth, edges
        var shaderProgram;
        var pastoShader;
        var time=0;

        var gl;
        var mat4=glMatrix.mat4;
        var mat3=glMatrix.mat3;
        var vec3=glMatrix.vec3;
        var vec4=glMatrix.vec4;

        var matrizProyeccion = mat4.create();
        var matrizVista = mat4.create();

        var $canvas=$("#myCanvas");
        var aspect=$canvas.width()/$canvas.height();

        //menu
        //var distanciaCamara=5.00;
        //var alturaCamara=-1.6;
        var alturaGrua=0.7;
        var valorGrua = 0.7;
        var rotarCabina=0.;
        var rotoGruaAnt = 0.;
        var alturaCable=0.1;
        var valorCable = 0.1;
        var anchoVidrio = 3.;
        var valorAnchoVidrio = 3.;
        var altoVidrio = 3.;
        var valorAltoVidrio = 3.;
        var pisosTramo1 = 3.;
        var pisosTramo2 = 3.;
        var generarEdificio = false;

        var cantTextures = 1;

        var lighting="true";
        var vertexShaderSource;
        var fragmentShaderSource;
        var tierraVertexShaderSource;
        var tierraFragmentShaderSource;

        var current_cam = 1; //1 es drone, 2 es orbital
        var drone = new DroneCameraControl([0,2,5]);
        var orbital = new OrbitalCameraControl();
        orbital.setEventListeners();

        var glTextures = {};
        var imagenTextura = ["textures/columnas.jpg", "textures/grua.jpg", "textures/losa.jpg", "textures/madera.jpg", "textures/pasto.jpg"];
        var TEXTURES = [];
        var texture;
        //const texture;// = gl.createTexture();

        function initGL(canvas) {

            try {
                gl = canvas.getContext("webgl");
                gl.canvas.width=$canvas.width();
                gl.canvas.height=$canvas.height();
            } catch (e) {
                console.error(e);
            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function loadShaders(){

            $.when(loadVS(), loadVS2(), loadFS(), loadFS2()).done(function(res1,res2, res3, res4){
                //this code is executed when all ajax calls are done
                //aca iria init texture y luego webglstart
                webGLStart1();
                //console.log('termino webglstart1');
                initTextures();
            });

            function loadVS() {
                return  $.ajax({
                    url: "shaders/vertex-shader.glsl",
                    success: function(result){
                        vertexShaderSource=result;
                    }
                });
            }

            function loadVS2() {
                return  $.ajax({
                    url: "shaders/tierra-vertex-shader.glsl",
                    success: function(result){
                        tierraVertexShaderSource=result;
                    }
                });
            }

            function loadFS() {
                return  $.ajax({
                    url: "shaders/fragment-shader.glsl",
                    success: function(result){
                        fragmentShaderSource=result;
                    }
                });
            }

            function loadFS2() {
                return  $.ajax({
                    url: "shaders/tierra-fragment-shader.glsl",
                    success: function(result){
                        tierraFragmentShaderSource=result;
                    }
                });
            }

        }

        function getShader(gl,code,type) {

            var shader;

            if (type == "fragment")
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            else // "vertex"
                shader = gl.createShader(gl.VERTEX_SHADER);

            gl.shaderSource(shader, code);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log('Error en la compilación del shader: ', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function onResize(){
            gl.canvas.width=$canvas.width();
            gl.canvas.height=$canvas.height();
            aspect=$canvas.width()/$canvas.height();
        }

        function getShaderSource(url) {
            var req = new XMLHttpRequest();
            req.open("GET", url, false);
            req.send(null);
            return (req.status == 200) ? req.responseText : null;
        };

        function initShaders(vs, fs) {

            //Shader de texturas
            var fragmentShader= getShader(gl, vertexShaderSource,"vertex");
            var vertexShader= getShader(gl, fragmentShaderSource,"fragment");

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aUv");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
            shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
            shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
            shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
            shaderProgram.frameUniform = gl.getUniformLocation(shaderProgram, "time");
            shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");

            //Shader de pasto
            /*
            var pasto_fragmentShader= getShader(gl, tierraVertexShaderSource,"vertex");
            var pasto_vertexShader= getShader(gl, tierraFragmentShaderSource,"fragment");

            pastoShader = gl.createProgram();
            gl.attachShader(pastoShader, pasto_vertexShader);
            gl.attachShader(pastoShader, pasto_fragmentShader);
            gl.linkProgram(pastoShader);

            if (!gl.getProgramParameter(pastoShader, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(pastoShader);

            pastoShader.vertexPositionAttribute = gl.getAttribLocation(pastoShader, "aPosition");
            gl.enableVertexAttribArray(pastoShader.vertexPositionAttribute);

            pastoShader.textureCoordAttribute = gl.getAttribLocation(pastoShader, "aUv");
            gl.enableVertexAttribArray(pastoShader.textureCoordAttribute);

            pastoShader.vertexNormalAttribute = gl.getAttribLocation(pastoShader, "aNormal");
            gl.enableVertexAttribArray(pastoShader.vertexNormalAttribute);

            pastoShader.pMatrixUniform = gl.getUniformLocation(pastoShader, "uPMatrix");
            pastoShader.mMatrixUniform = gl.getUniformLocation(pastoShader, "uMMatrix");
            pastoShader.vMatrixUniform = gl.getUniformLocation(pastoShader, "uVMatrix");
            pastoShader.nMatrixUniform = gl.getUniformLocation(pastoShader, "uNMatrix");
            pastoShader.samplerUniform = gl.getUniformLocation(pastoShader, "uSampler");
            pastoShader.useLightingUniform = gl.getUniformLocation(pastoShader, "uUseLighting");
            pastoShader.ambientColorUniform = gl.getUniformLocation(pastoShader, "uAmbientColor");
            pastoShader.frameUniform = gl.getUniformLocation(pastoShader, "time");
            pastoShader.lightingDirectionUniform = gl.getUniformLocation(pastoShader, "uLightPosition");
            pastoShader.directionalColorUniform = gl.getUniformLocation(pastoShader, "uDirectionalColor");
*/
        }

        function initTextures(){
            //textureColumna = loadTexture("textures/columnas.jpg");
            textureColumna = loadTexture(imagenTextura[0]);
            textureGrua = loadTexture(imagenTextura[1]);
            textureLosa = loadTexture(imagenTextura[2]);
            textureMadera = loadTexture(imagenTextura[3]);
            texturePasto = loadTexture(imagenTextura[4]);
            //console.log('termino de cargar las texturas');
            webGLStart2();

            }

        function loadTexture(path) {

            var texture = gl.createTexture();
            var image = new Image();

            image.onload = function() {
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
                gl.generateMipmap(gl.TEXTURE_2D);
                //gl.bindTexture(gl.TEXTURE_2D, null);
                /*
                if (cantTextures > 1)
                    {   console.log('faltan cargar ' + cantTextures);
                        cantTextures --;}
                else
                    {   
                        console.log('termino de cargar las texturas');
                        webGLStart2();
                    }
                */
            }
            image.src = path;
            texture.image = image;
            //agrega la textura a glTextures
            return texture;
            }

            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
                }

            function drawScene() {

            // Se configura el viewport dentro del "canvas".
            // En este caso se utiliza toda el área disponible
            gl.viewport(0, 0, $canvas.width(), $canvas.height());

            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clearColor(0.0,0.0,0.0,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        
            // Se configura la matriz de proyección
            mat4.identity(matrizProyeccion);
            mat4.perspective(matrizProyeccion, 30, aspect, 0.1, 100.0);
            mat4.scale(matrizProyeccion,matrizProyeccion,[1,-1,1]); // parche para hacer un flip de Y, parece haber un bug en glmatrix

            // Se inicializan las variables asociadas con la Iluminación
            gl.uniform1f(shaderProgram.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(shaderProgram.directionalColorUniform, 1., 0., 0.);
            gl.uniform1i(shaderProgram.useLightingUniform,(lighting=="true"));

            /*
            gl.uniform1f(pastoShader.frameUniform, time/10.0 );
            gl.uniform3f(pastoShader.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(pastoShader.directionalColorUniform, 1., 0., 0.);
            gl.uniform1i(pastoShader.useLightingUniform,(lighting=="true"));
            */
            if (current_cam ==1 )
                {
                viewMatrix = drone.getViewMatrix();
                drone.update();}
            else
                {
                viewMatrix = orbital.getViewMatrix();
                orbital.setEventListeners(gl.canvas);
                orbital.update();}

            var lightPosition = [10.0,0.0, 3.0];
            gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);
            //gl.uniform3fv(pastoShader.lightingDirectionUniform, lightPosition);

            dibujarGeometria();

        }

        function dibujarGeometria(){
            /*
            0 textureColumna;
            1 textureGrua ;
            2 textureLosa ;
            3 textureMadera;
            4 texturePasto ;
            */
           
            grua_G1.draw(null, textureMadera);
            grua_A1.draw(null, textureGrua);
            for (i=0; i<Math.trunc(pisosTramo1); i++){
                piso1.setPosicion(0.,i*1.,0.);
                piso1.draw(null, textureColumna);}
            for (i=0; i<Math.trunc(pisosTramo2); i++){
                piso2.setPosicion(0.,(i*1.) + pisosTramo1,0.);
                piso2.draw(null, textureMadera);}    
            tapa_edif.setPosicion(-5.5,pisosTramo1+pisosTramo2,9.);
            tapa_edif.draw(null, textureLosa);
                
            //tobogan.draw();
            /*
            for (i=0; i<3; i++){
                //primer tramo
                tobogan.setPosicion(4.- (i/2)*0.9,3.+ (i/2) ,12.- i*0.5);
                if(i=0){
                    tobogan_inv.setPosicion(-2. + (i*1.5),-2.2, 3.+ i);
                    tobogan_inv.setRotacion(Math.PI/2, 0.,Math.PI/2);}
            
                //tobogan_sub.setPosicion(0.,-3.,0.5);
                tobogan.draw();}
            */             
                
            for (i=0; i<20; i++){
                for (m=0;m<30;m++){
                    pasto.setPosicion(-10.+i,0.,-9.+ m);
                    pasto.draw(null, texturePasto, "pasto");}
            }
        }

        function tick() {
            requestAnimFrame(tick);
            time+=1/60;
            //reviso los cambios de cada control
            if (alturaGrua!=valorGrua)
                {   if (alturaGrua - valorGrua <0)
                        expandirGrua(valorGrua);
                    else
                        expandirGrua(alturaGrua);
                    valorGrua = alturaGrua;}

            if (Math.trunc(rotoGruaAnt)!=Math.trunc(rotarCabina))
            {   rotoGruaAnt = Math.trunc(rotarCabina);
                rotarCabina = Math.trunc(rotarCabina)*Math.PI/2;
                rotacionCabina(rotarCabina);}

            if (alturaCable!=valorCable)
                {   if (alturaCable - valorCable <0)
                        expandirCable(alturaCable);
                    else
                        expandirCable(valorCable);
                    valorCable = alturaCable;}

            if (anchoVidrio!=valorAnchoVidrio)
                {
                    valorAnchoVidrio = anchoVidrio;
                    cambiarVentanas(anchoVidrio, altoVidrio);
                }                    

            if (altoVidrio!=valorAltoVidrio)
            {
                valorAltoVidrio = altoVidrio;
                cambiarVentanas(anchoVidrio, altoVidrio);
            }                    

            window.addEventListener("keydown", (event) => {
                if (event.keyCode == 49) {
                // 1 para la Drone
                    current_cam = 1;
                    matrizVista = drone.getViewMatrix();
                    drone.update();}
                if (event.keyCode == 50) {
                // 2 para la Orbital
                    current_cam = 2;
                    matrizVista = orbital.getViewMatrix();
                    //poner cuando lo inicio
                    //orbital.setEventListeners(gl.canvas);
                    orbital.update();}
            })
            
            if (current_cam == 1) {
                matrizVista = drone.getViewMatrix();
                drone.update();}
            else {
                // 2 para la Orbital
                matrizVista = orbital.getViewMatrix();
                //orbital.setEventListeners(gl.canvas);
                orbital.update();}

            drawScene();
        }

        function initMenu(){
            var gui = new dat.GUI();
            gui.add(window, "modo",["wireframe","smooth","edges"]);
            gui.add(window, "alturaGrua",-1.,0.7).step(0.01);
            gui.add(window, "rotarCabina",0.,4.).step(0.01);
            gui.add(window, "pisosTramo1",3.,10.).step(0.01);
            gui.add(window, "pisosTramo2",3.,10.).step(0.01);
            //no anda las funciones asi que no lo muestro
            //gui.add(window, "alturaCable",0.1,0.35).step(0.01);
            gui.add(window, "anchoVidrio",3.,4.).step(0.01);
            gui.add(window, "altoVidrio",3.,4.).step(0.01);

        }

        function webGLStart1() {
            var canvas = document.getElementById("myCanvas");
            initGL(canvas);
            //camara = new CameraControl([0,2,5], canvas);

        }
        function webGLStart2() {
            //console.log('ingreso a Webglstart2');
            initShaders("vertex","fragment");

            crearGeometriaGrua();
            crearGeometriaEdificio();
            //crearGeometriaTobogan();
            crearGeometriaPasto();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            $(window).on("resize",onResize);
            initMenu();            
            tick();
        }

        // cuando el documento HTML esta completo, iniciamos la aplicación
        $(document).ready(function(){
            loadShaders();
        })

    </script>

</body>
</html>
