<!doctype html>
<head>
    <script src="js/jquery.js"></script>
    <script src="js/gl-matrix-3.3.0.js"></script>
    <script src="js/webgl-utils.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="js/droneCamera.js"></script>
    <script src="modulo-geometria.js"></script>
    <script src="modulo-calculos.js"></script>
    <style>
        html{
            height: 100%;
        }
        body{
            padding: 0;
            margin: 0;
            height: 100%;;
        }

        #myCanvas{
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>

</head>

<body>

    <canvas id="myCanvas" >
        Your browser does not support the HTML5 canvas element.
    </canvas>


    <script>

        var vertexShaderFile="vertex-shader.glsl";
        var modo="edges"; // wireframe, smooth, edges
        var shaderProgram;
        var time=0;

        var gl;
        var mat4=glMatrix.mat4;
        var mat3=glMatrix.mat3;
        var vec3=glMatrix.vec3;
        var vec4=glMatrix.vec4;

        var grua_A1;
        var grua_A2;
        var grua_A3;
        var grua_A4;
        var grua_B1;
        var grua_B2;
        var grua_B3;
        var grua_B4;
        var grua_C1;
        var grua_D0;
        var grua_D1;
        var grua_D2;
        var grua_D3;
        var grua_D4;
        var grua_E1;
        var grua_E2;
        var grua_F0;
        var grua_F1;
        var grua_F1a;
        var grua_F2;
        var grua_F3;
        var grua_G1;

        var matrizProyeccion = mat4.create();
        var matrizVista = mat4.create();

        var $canvas=$("#myCanvas");
        var aspect=$canvas.width()/$canvas.height();

        var distanciaCamara=5.00;
        var alturaCamara=-1.6;
        var alturaGrua=0.7;
        var valorGrua = 0.7;
        var rotarCabina=0.;
        var rotoGruaAnt = 0.;
        var alturaCable=0.1;
        var valorCable = 0.1;

        var lighting="true";
        var vertexShaderSource;
        var fragmentShaderSource;

        var drone = new DroneCameraControl();

        function initGL(canvas) {

            try {
                gl = canvas.getContext("webgl");
                gl.canvas.width=$canvas.width();
                gl.canvas.height=$canvas.height();
            } catch (e) {
                console.error(e);
            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function loadShaders(){

            $.when(loadVS(), loadFS()).done(function(res1,res2){
                //this code is executed when all ajax calls are done
                webGLStart();
            });

            function loadVS() {
                return  $.ajax({
                    url: "shaders/"+vertexShaderFile,
                    success: function(result){
                        vertexShaderSource=result;
                    }
                });
            }

            function loadFS() {
                return  $.ajax({
                    url: "shaders/fragment-shader.glsl",
                    success: function(result){
                        fragmentShaderSource=result;
                    }
                });
            }
        }

        function getShader(gl,code,type) {

            var shader;

            if (type == "fragment")
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            else // "vertex"
                shader = gl.createShader(gl.VERTEX_SHADER);

            gl.shaderSource(shader, code);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        function onResize(){
            gl.canvas.width=$canvas.width();
            gl.canvas.height=$canvas.height();
            aspect=$canvas.width()/$canvas.height();
        }

        function getShaderSource(url) {
            var req = new XMLHttpRequest();
            req.open("GET", url, false);
            req.send(null);
            return (req.status == 200) ? req.responseText : null;
        };

        function initShaders() {

            var fragmentShader= getShader(gl, vertexShaderSource,"vertex");
            var vertexShader= getShader(gl, fragmentShaderSource,"fragment");

            shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise shaders");
            }

            gl.useProgram(shaderProgram);

            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aUv");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
            shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
            shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
            shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
            shaderProgram.frameUniform = gl.getUniformLocation(shaderProgram, "time");
            shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
        }

        function Objeto3D(ancho, largo){
            this.matrizModelado=mat4.create();
            mat4.identity(this.matrizModelado);
            this.normalMatrix = mat3.create();
            this.posicion=vec3.create();
            this.rotacion=vec3.create();
            //this.rotacion=[0.,0.,0.];
            
            this.escala=vec3.create();
            this.hijos=[];

            this.webgl_position_buffer = null;
            this.webgl_normal_buffer = null;
            this.webgl_texture_coord_buffer = null;
            this.webgl_index_buffer = null;

            this.agregarHijo=function(h) {this.hijos.push(h)}
            //this.quitarHijo=function(h) { … }

            this.setPosicion=function(x,y,z) { 
                this.posicion = [x,y,z];
                }

            this.setRotacion=function(angulo, x,y,z) {
                //guardo el ángulo en cada posicion
                this.rotacion = [x,y,z];
                }

            this.setEscala=function(x,y,z) { 
                this.escala = [x,y,z];
                }

            //agrego esto pero no lo uso, hasta deberia evaluar si va
            this.getPosicion=function(u,v){
                var x=(u-0.5)*ancho;
                var z=(v-0.5)*largo;
                return [x,z,0];
            }
            //agrego esto pero no lo uso, hasta deberia evaluar si va
            this.getNormal=function(u,v){
                return [0,1,0];
            }
            //agrego esto pero no lo uso, hasta deberia evaluar si va
            this.getCoordenadasTextura=function(i,j, filas, columnas){
                return [1.0/filas * i,1.0/columnas * j];
            }

            this.setMatrixUniforms=function() {
                gl.uniformMatrix4fv(shaderProgram.mMatrixUniform, false, this.matrizModelado);
                gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, matrizVista);
                gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, matrizProyeccion);

                mat3.fromMat4(this.normalMatrix,this.matrizModelado); // normalMatrix= (inversa(traspuesta(matrizModelado)));

                mat3.invert(this.normalMatrix, this.normalMatrix);
                mat3.transpose(this.normalMatrix, this.normalMatrix);

                gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, this.normalMatrix);
                }
            
            this.initBuffers = function(filas,columnas, tipo){
    
                positionBuffer = [];
                normalBuffer = [];
                uvBuffer = [];
                var matIdentidad = [];
                var mat = mat3.create();
                mat3.identity(mat);
                matIdentidad.push(mat);
                if (tipo == 'cuadrado')
                    {vertices = crearCuadrado();
                    //uso dos niveles
                    for (j=0; j<filas; j++){
                        y = j*1.0;
                        //if (tipo == 'cuadrado')
                        matrizNivel = crearRecorridoCuadrado(0.0, y, 0.0);
                        translado = vec3.create();
                        translado = vec3.fromValues(matrizNivel[12],matrizNivel[13],matrizNivel[14]);
                        //guardo en el position buffer los vertices
                        for (i=0; i< vertices.length; i++){
                            var pos = vec3.create();
                            vec3.copy(pos,vertices[i]);
                            vec3.add(pos,translado, pos);
                            positionBuffer.push(pos[0]);
                            positionBuffer.push(pos[1]);
                            positionBuffer.push(pos[2]);

                            var u=j/columnas;
                            var v=i/filas;
                            var nrm=this.getNormal(u,v);
                            normalBuffer.push(nrm[0]);
                            normalBuffer.push(nrm[1]);
                            normalBuffer.push(nrm[2]);
                            var uvs=this.getCoordenadasTextura(i,j, filas, columnas);
                            uvBuffer.push(uvs[0]);
                            uvBuffer.push(0.2);
                            uvBuffer.push(uvs[1]);
                            var u = (i / (filas - 1));
                            var v = (j / (columnas - 1));
                            uvBuffer.push(v);
                            uvBuffer.push(u);
                        }
                    }
                    }
                if (tipo == 'circulo')
                    {radio = 0.25;
                    var y = 15.;
                    vertices = crearCirculo(radio, y);
                    //uso dos niveles
                    for (j=0; j<filas; j++){
                        y = j*1.0;
                        matrizNivel = crearRecorridoCirculo(0.0, y, 0.0);
                        translado = vec3.create();
                        translado = vec3.fromValues(matrizNivel[12],matrizNivel[13],matrizNivel[14]);
                        //guardo en el position buffer los vertices
                        for (i=0; i< columnas; i++){
                            var pos = vec3.create();
                            vec3.copy(pos,vertices[i]);
                            vec3.add(pos,translado, pos);

                            positionBuffer.push(pos[0] );
                            positionBuffer.push(pos[1] );
                            positionBuffer.push(pos[2] );

                            var u=j/columnas;
                            var v=i/filas;
                            var nrm=this.getNormal(u,v);
                            normalBuffer.push(nrm[0]);
                            normalBuffer.push(nrm[1]);
                            normalBuffer.push(nrm[2]);
                            var uvs=this.getCoordenadasTextura(i,j, filas, columnas);
                            uvBuffer.push(uvs[0]);
                            uvBuffer.push(0.2);
                            uvBuffer.push(uvs[1]);
                            var u = (i / (filas - 1));
                            var v = (j / (columnas - 1));
                            uvBuffer.push(v);
                            uvBuffer.push(u);
                        }
                    }
                    }

                    if (tipo == 'cabina')
                    {vertices = crearCabina();
                    //uso dos niveles
                    for (j=0; j<filas; j++){
                        y = j*1.0;
                        //if (tipo == 'cuadrado')
                        matrizNivel = crearRecorridoCuadrado(0.0, y, 0.0);
                        translado = vec3.create();
                        translado = vec3.fromValues(matrizNivel[12],matrizNivel[13],matrizNivel[14]);
                        //guardo en el position buffer los vertices
                        for (i=0; i< vertices.length; i++){
                            var pos = vec3.create();
                            vec3.copy(pos,vertices[i]);
                            vec3.add(pos,translado, pos);
                            positionBuffer.push(pos[0]);
                            positionBuffer.push(pos[1]);
                            positionBuffer.push(pos[2]);

                            var u=j/columnas;
                            var v=i/filas;
                            var nrm=this.getNormal(u,v);
                            normalBuffer.push(nrm[0]);
                            normalBuffer.push(nrm[1]);
                            normalBuffer.push(nrm[2]);
                            var uvs=this.getCoordenadasTextura(i,j, filas, columnas);
                            uvBuffer.push(uvs[0]);
                            uvBuffer.push(0.2);
                            uvBuffer.push(uvs[1]);
                            var u = (i / (filas - 1));
                            var v = (j / (columnas - 1));
                            uvBuffer.push(v);
                            uvBuffer.push(u);
                        }
                    }
                    }
                //console.log(positionBuffer);

                // Buffer de indices de los triangulos
                indexBuffer=[];
                for (var i=0;i<filas-1;i++){
                        indexBuffer.push(i*columnas);
                        for (var j=0;j<columnas-1;j++){
                            indexBuffer.push(i*columnas+j);
                            indexBuffer.push((i+1)*columnas+j);
                            indexBuffer.push(i*columnas+j+1);
                            indexBuffer.push((i+1)*columnas+j+1);
                        }
                        indexBuffer.push((i+1)*columnas+columnas-1);
                }
                //console.log(indexBuffer);

            // Creación e Inicialización de los buffers a nivel de OpenGL
                this.webgl_normal_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_normal_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalBuffer), gl.STATIC_DRAW);
                this.webgl_normal_buffer.itemSize = 3;
                this.webgl_normal_buffer.numItems = normalBuffer.length / 3;

                this.webgl_texture_coord_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_texture_coord_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(uvBuffer), gl.STATIC_DRAW);
                this.webgl_texture_coord_buffer.itemSize = 2;
                this.webgl_texture_coord_buffer.numItems = uvBuffer.length / 2;

                this.webgl_position_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_position_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positionBuffer), gl.STATIC_DRAW);
                this.webgl_position_buffer.itemSize = 3;
                this.webgl_position_buffer.numItems = positionBuffer.length / 3;

                this.webgl_index_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.webgl_index_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexBuffer), gl.STATIC_DRAW);
                this.webgl_index_buffer.itemSize = 1;
                this.webgl_index_buffer.numItems = indexBuffer.length;
            }

            this.actualizarMatrizModelado = function(){
                mat4.identity(this.matrizModelado);
                if(this.posicion[0]!=0. || this.posicion[1]!=0. || this.posicion[2]!=0.)
                    mat4.translate(this.matrizModelado, this.matrizModelado, this.posicion);
                if(this.rotacion[0]!=0. && typeof this.rotacion[0] !== "undefined")
                    mat4.rotate(this.matrizModelado, this.matrizModelado, this.rotacion[0], [1.0,0.,0.]);
                if(this.rotacion[1]!=0. && typeof this.rotacion[1] !== "undefined")
                    mat4.rotate(this.matrizModelado, this.matrizModelado, this.rotacion[1], [0.,1.0,0.]);
                if(this.rotacion[2]!=0. && typeof this.rotacion[2] !== "undefined")
                    mat4.rotate(this.matrizModelado, this.matrizModelado, this.rotacion[2], [0.,0.,1.0]);
                if(this.escala[0]!=0. || this.escala[1]!=0. || this.escala[2]!=0.)
                    mat4.scale(this.matrizModelado, this.matrizModelado, this.escala);

            }

            this.draw = function(matPadre){
                    this.actualizarMatrizModelado();
                    // concatenamos las transformaciones padre/hijo
                    if(matPadre){
                        mat4.multiply(this.matrizModelado,matPadre,this.matrizModelado);
                        }

                    if (this.webgl_position_buffer && this.webgl_index_buffer){
                    // dibujamos la malla de triángulos con WebGL
                    // si el objeto tiene geometría asociada
                        this.setMatrixUniforms();

                        // Se configuran los buffers que alimentaron el pipeline
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_position_buffer);
                        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, this.webgl_position_buffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_texture_coord_buffer);
                        gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, this.webgl_texture_coord_buffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ARRAY_BUFFER, this.webgl_normal_buffer);
                        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, this.webgl_normal_buffer.itemSize, gl.FLOAT, false, 0, 0);

                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.webgl_index_buffer);

                        if (modo!="wireframe"){
                            gl.uniform1i(shaderProgram.useLightingUniform,(lighting=="true"));
                            gl.drawElements(gl.TRIANGLE_STRIP, this.webgl_index_buffer.numItems, gl.UNSIGNED_SHORT, 0);
                        }

                        if (modo!="smooth") {
                            gl.uniform1i(shaderProgram.useLightingUniform,false);
                            gl.drawElements(gl.LINE_STRIP, this.webgl_index_buffer.numItems, gl.UNSIGNED_SHORT, 0);
                        }
                    }
                    for (var i=0;i<this.hijos.length;i++){
                        //le mando la matriz de modelado del padre
                        this.hijos[i].draw(this.matrizModelado);}
            }

        }

        function drawScene() {

            // Se configura el viewport dentro del "canvas".
            // En este caso se utiliza toda el área disponible
            gl.viewport(0, 0, $canvas.width(), $canvas.height());

            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clearColor(0.0,0.0,0.0,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            // Se configura la matriz de proyección
            mat4.identity(matrizProyeccion);
            mat4.perspective(matrizProyeccion, 30, aspect, 0.1, 100.0);
            mat4.scale(matrizProyeccion,matrizProyeccion,[1,-1,1]); // parche para hacer un flip de Y, parece haber un bug en glmatrix

            // Se inicializan las variables asociadas con la Iluminación

            gl.uniform1f(shaderProgram.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.6, 0.6, 0.6 );
            //gl.uniform3f(shaderProgram.directionalColorUniform, 1., 0., 0.);
            gl.uniform1i(shaderProgram.useLightingUniform,(lighting=="true"));

            drone.getMatrix();
            // Definimos la ubicación de la camara
            mat4.lookAt(matrizVista,
                vec3.fromValues(0,alturaCamara,distanciaCamara),
                vec3.fromValues(0,0,0),
                vec3.fromValues(0,1,0)
            );

            var lightPosition = [10.0,0.0, 3.0];
            gl.uniform3fv(shaderProgram.lightingDirectionUniform, lightPosition);


            if (alturaGrua!=valorGrua)
                {
                    if (alturaGrua - valorGrua <0)
                        expandirGrua(valorGrua);
                    else
                        expandirGrua(alturaGrua);
                    valorGrua = alturaGrua;
                }

            if (rotoGruaAnt!=rotarCabina)
            {
                rotoGruaAnt = rotarCabina;
                rotarCabina = rotarCabina*Math.PI/4;
                rotacionCabina(rotarCabina);
            }

            if (alturaCable!=valorCable)
                {
                    if (alturaCable - valorCable <0)
                        expandirCable(alturaCable);
                    else
                        expandirCable(valorCable);
                    valorCable = alturaCable;
                }

            dibujarGeometria();

        }

        function dibujarGeometria(){
            grua_A1.draw();
        }

        function tick() {
            requestAnimFrame(tick);
            time+=1/60;

            drone.update();
            drawScene();
        }

        function initMenu(){
            var gui = new dat.GUI();
            gui.add(window, "distanciaCamara",0.01,5).step(0.01);
            gui.add(window, "alturaCamara",-2,2).step(0.01);
            gui.add(window, "modo",["wireframe","smooth","edges"]);
            gui.add(window, "alturaGrua",-1.,0.7).step(0.01);
            gui.add(window, "rotarCabina",0.,8.).step(0.01);
            gui.add(window, "alturaCable",0.1,0.35).step(0.01);


        }

        function expandirGrua(altura)
        {
            if (altura < 0.08)
                grua_B1.setPosicion(0.75,altura + 3.,-0.25);

            grua_C1.setPosicion(0.5,altura+0.8,-0.5);
            grua_D0.setPosicion(0.12,altura + 3.,-0.65);
            grua_E1.setPosicion(0.5,altura + 3.,-0.45);
            grua_E2.setPosicion(0.5,altura + 3.,-0.45);
            grua_F1.setPosicion(4.5,altura +3.1,-0.45);
            grua_F0.setPosicion(4.5,altura +3.1,1.15);
        }

        function expandirCable(altura)
        {
            //tengo que escalar el cable para que sea mas largo
            grua_F1.setEscala(0.,-altura,0.);
            //F2, F3 y G1 se mueven
            //z es el alto, y profundidad, x es x esta cambiado porque depende de F0
            posicion_z = Math.pow( altura * 10., 2.) ;
            grua_F2.setPosicion(0.25,16.5,posicion_z -2. + Math.pow( 2., 2.) ); 
            grua_F3.setPosicion(0.25,16.5,posicion_z -2. + Math.pow( 2., 2.)); 
            grua_G1.setPosicion(-2., 8.,posicion_z -1. + Math.pow( 2.5, 2.));  

        }
        
        function rotacionCabina(alpha)
        {
            grua_D0.setRotacion(alpha, Math.PI/2,0.);
        }

        function crearGeometria(){
            // GRUA
            // pieza A
            //ancho, largo
            grua_A1 = new Objeto3D(1,1);
            grua_A1.initBuffers(3, 2,'cuadrado');
            grua_A2 = new Objeto3D(1,1);
            grua_A2.initBuffers(3, 2,'cuadrado');        
            grua_A3 = new Objeto3D(1,1);
            grua_A3.initBuffers(3, 2,'cuadrado');
            grua_A4 = new Objeto3D(1,1);
            grua_A4.initBuffers(3, 2,'cuadrado');          
            grua_A1.agregarHijo(grua_A2);
            grua_A1.agregarHijo(grua_A3);
            grua_A1.agregarHijo(grua_A4);
            grua_A2.setRotacion(0.,0.,Math.PI/2);
            grua_A3.setPosicion(0.,0.,-1.);
            grua_A4.setRotacion(0., 0.,-Math.PI/2);
            grua_A4.setPosicion(1.,0.,-1.);
            // pieza B
            grua_B1 = new Objeto3D(1,1);
            grua_B1.initBuffers(4, 2,'cuadrado');
            grua_B2 = new Objeto3D(1,1);
            grua_B2.initBuffers(4, 2,'cuadrado');        
            grua_B3 = new Objeto3D(1,1);
            grua_B3.initBuffers(4, 2,'cuadrado');
            grua_B4 = new Objeto3D(1,1);
            grua_B4.initBuffers(4, 2,'cuadrado');
            grua_B1.agregarHijo(grua_B2);
            grua_B1.agregarHijo(grua_B3);
            grua_B1.agregarHijo(grua_B4);
            grua_A1.agregarHijo(grua_B1);
            //muevo los hijos
            grua_B2.setPosicion(1.,0.,1.);
            grua_B2.setRotacion(0.,0., Math.PI/2.0);
            grua_B3.setPosicion(0.,0.,1.);
            grua_B4.setRotacion(0.,0.,-Math.PI/2.0);
            //se aplica a todos porque es el padre
            grua_B1.setPosicion(0.75,3.,-0.25);
            grua_B1.setEscala(-0.5,-0.5,-0.5);
            // pieza C es un circulo / cilindro
            grua_C1 = new Objeto3D(8,8);
            grua_C1.initBuffers(11, 16,'circulo');
            grua_C1.setEscala(0.5,0.1,0.5);
            grua_A1.agregarHijo(grua_C1);
            grua_C1.setPosicion(0.5,1.35,-0.5);
            // pieza D es la cabina
            // necesito D0 para que haga de centro de la cabina así puedo rotar después, es un contenedor
            grua_D0 = new Objeto3D(1,1);
            grua_D0.initBuffers(1, 1,'cabina');
            grua_D1 = new Objeto3D(2,2);
            grua_D1.initBuffers(3, 3,'cabina');
            grua_D2 = new Objeto3D(2,2);
            grua_D2.initBuffers(3, 3,'cabina');
            grua_D3 = new Objeto3D(3,3);
            grua_D3.initBuffers(3, 5,'cuadrado');        
            grua_D4 = new Objeto3D(2,2);
            grua_D4.initBuffers(3, 2,'cuadrado');        
            grua_D0.setRotacion(0.,Math.PI/2,0.);
            grua_D0.setPosicion(0.12,3.7,-0.65);
            grua_D0.setEscala(0.4,0.2,0.4);
            grua_D0.agregarHijo(grua_D1);
            grua_D0.agregarHijo(grua_D2);
            grua_D0.agregarHijo(grua_D3);
            grua_D0.agregarHijo(grua_D4);
            grua_A1.agregarHijo(grua_D0);

            grua_D4.setPosicion(2.,0.,0.);
            grua_D4.setEscala(1.3,0.5,1.);
            grua_D4.setRotacion(0.,0.,Math.PI/2);

            grua_D3.setPosicion(0.,1.6,0.);
            grua_D3.setRotacion(0.,-Math.PI/2,Math.PI/2);
            grua_D2.setPosicion(2.,1.6,0.);
            grua_D2.setRotacion(0.,-Math.PI/2, Math.PI);
            grua_D1.setPosicion(2.,0.6,0.);
            grua_D1.setRotacion(0.,-Math.PI/2, Math.PI);

            //pieza E - es la barra acostada
            grua_E1 = new Objeto3D(2,2);
            grua_E1.initBuffers(4, 2,'cuadrado');
            grua_E1.setEscala(5.,0.1,0.);
            grua_E1.setPosicion(0.5,3.7,-0.45);
            grua_E2 = new Objeto3D(2,2);
            grua_E2.initBuffers(4,2,'cuadrado');
            grua_E2.setEscala(5.,0.1,0.);
            grua_E2.setPosicion(0.5,3.7,-0.55);
            //no son padre e hijo porque no se porque rollo no me toma los cambios sobre el padre
            grua_A1.agregarHijo(grua_E1);
            grua_A1.agregarHijo(grua_E2);

            //pieza F0 va a ser el contenedor para F y G, ya que como van con distintas escalas necesito que no se molesten
            //voy a hacerla tipo cilindro así se parece a la imagen original
            grua_F0 = new Objeto3D(4,4);
            grua_F0.initBuffers(4, 6,'circulo');
            grua_F0.setEscala(0.3,-0.1,0.3);
            grua_F0.setPosicion(4.5,3.8,1.15);
            grua_F0.setRotacion(0.,Math.PI/2,0.);
            grua_A1.agregarHijo(grua_F0);

            //pieza F - cables
            grua_F1 = new Objeto3D(1,1);
            grua_F1.initBuffers(11, 2,'cuadrado');
            grua_F1.setPosicion(4.5,3.75,-0.45);
            grua_F1.setEscala(-0.02,-0.105,-1.); 
            grua_A1.agregarHijo(grua_F1);

            //este es un punto que cuelga al final de F1. Ese punto se debería mover cuando F1 escale y en consecuencia moverse sus hijos F2, F3 y G0
            //no funciono.....
            //grua_F1a = new Objeto3D(2,2);
            //grua_F1a.initBuffers(2, 2,'circulo');
            //grua_F1a.setPosicion(0.,-5.,0.);
            //grua_F1.agregarHijo(grua_F1a);

            //F2, F3 y G0 no pueden depender de F1 porque cuando expandis el cable, cambias la escala y los afectas
            //por eso, dependen de F1a
            grua_F2 = new Objeto3D(2,2);
            grua_F2.initBuffers(4, 2,'cuadrado');
            grua_F3 = new Objeto3D(2,2);
            grua_F3.initBuffers(4, 2,'cuadrado');
            grua_F0.agregarHijo(grua_F2);
            grua_F0.agregarHijo(grua_F3);

            grua_F2.setPosicion(0.25,16.5,3.5);
            grua_F2.setRotacion(0.,0., -Math.PI/4);
            grua_F2.setEscala(1.,0.3,1.); 

            grua_F3.setPosicion(0.25,16.5,3.5);
            grua_F3.setRotacion(0.,0., -Math.PI*3/4);
            grua_F3.setEscala(1.,0.3,1.); 

            //pieza G - plataforma
            grua_G1 = new Objeto3D(2,2);
            grua_G1.initBuffers(3, 2,'cuadrado');
            grua_G1.setEscala(4.,8.,8.);
            grua_G1.setPosicion(-2.,8.,4.25); //z es el alto, y profundidad, x es x esta cambiado porque depende de F0
            grua_F0.agregarHijo(grua_G1);

            //bajo toda la escena -1 en y y en -1 en x
            grua_A1.setPosicion(-2.,-1.,0.);


        }

        function webGLStart() {
            var canvas = document.getElementById("myCanvas");
            initGL(canvas);
            initShaders();

            crearGeometria();

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.enable(gl.DEPTH_TEST);

            $(window).on("resize",onResize);
            initMenu();
            tick();
        }

        // cuando el documento HTML esta completo, iniciamos la aplicación
        $(document).ready(function(){
            loadShaders();
        })

    </script>

</body>
</html>
